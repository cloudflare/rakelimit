package main

import (
	"testing"

	"github.com/cloudflare/rakelimit/targetlimit"
)

func BenchmarkIPv4Pass(b *testing.B) {
	benchSrcPortLimit := targetlimit.Limit{
		PacketsPerSecond: float64(100),
		BurstSec:         float64(5),
	}

	benchSrcNetLimit := targetlimit.Limit{
		PacketsPerSecond: float64(100),
		BurstSec:         float64(5),
	}

	benchSrcIPLimit := targetlimit.Limit{
		PacketsPerSecond: float64(100),
		BurstSec:         float64(5),
	}

	benchDstLimit := targetlimit.Limit{
		PacketsPerSecond: float64(100),
		BurstSec:         float64(5),
	}

	tl, err := targetlimit.NewTargetLimit(benchSrcPortLimit, benchSrcNetLimit, benchSrcIPLimit, benchDstLimit)
	if err != nil {
		b.Fatalf("[-] Can't load targetlimit for benchmark: %v", err)
	}
	defer tl.Close()
	if err := tl.SetProgram("bpf_rate_limit_benchmark"); err != nil {
		b.Fatal(err)
	}
	// this is dns for A cloudflare.com to to 1.1.1.1
	payload := []byte{
		0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x08, 0x00, 0x45, 0x00,
		0x00, 0x53, 0x37, 0x82, 0x00, 0x00, 0x40, 0x11, 0x80, 0x56, 0xc0, 0xa8, 0x00, 0x18, 0x01, 0x01,
		0x01, 0x01, 0xd7, 0x78, 0x00, 0x35, 0x00, 0x3f, 0xc3, 0x12, 0x77, 0xb6, 0x01, 0x20, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0a, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x66, 0x6c, 0x61, 0x72,
		0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x29, 0x10, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0a, 0x00, 0x08, 0xb0, 0xa3, 0x2e, 0xa1, 0xe1, 0xba, 0xd9, 0x6a,
	}

	b.ResetTimer()
	result, duration, err := tl.Prog().Benchmark(payload, b.N, func() {
		b.ResetTimer()
	})
	_ = result
	if err != nil {
		b.Fatal(err)
	}

	b.ReportMetric(float64(duration.Nanoseconds()), "ns/op")
}

func BenchmarkIPv4Reject(b *testing.B) {
	zeroLimit := targetlimit.Limit{
		PacketsPerSecond: float64(10),
		BurstSec:         float64(0.0000000000000000000000000001),
	}

	tl, err := targetlimit.NewTargetLimit(zeroLimit, zeroLimit, zeroLimit, zeroLimit)
	if err != nil {
		b.Fatalf("[-] Can't load targetlimit for benchmark: %v", err)
	}
	defer tl.Close()

	// this is dns for A cloudflare.com to to 1.1.1.1
	payload := []byte{
		0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x08, 0x00, 0x45, 0x00,
		0x00, 0x53, 0x37, 0x82, 0x00, 0x00, 0x40, 0x11, 0x80, 0x56, 0xc0, 0xa8, 0x00, 0x18, 0x01, 0x01,
		0x01, 0x01, 0xd7, 0x78, 0x00, 0x35, 0x00, 0x3f, 0xc3, 0x12, 0x77, 0xb6, 0x01, 0x20, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0a, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x66, 0x6c, 0x61, 0x72,
		0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x29, 0x10, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0a, 0x00, 0x08, 0xb0, 0xa3, 0x2e, 0xa1, 0xe1, 0xba, 0xd9, 0x6a,
	}

	// first we'll make sure it works as expected, we actually drop packets straight away
	// (we actually need to do it twice because first packets are passed by default)

	//first
	_, _, err = tl.Prog().Test(payload)
	if err != nil {
		b.Fatal(err)
	}

	//second
	ret, _, err := tl.Prog().Test(payload)
	if err != nil {
		b.Fatal(err)
	}

	//it should be rejected, rejected is 0, so ensure it actually is
	if ret != 0 {
		b.Fatal(ret)
	}

	b.ResetTimer()
	result, duration, err := tl.Prog().Benchmark(payload, b.N, func() {
		b.ResetTimer()
	})
	_ = result
	if err != nil {
		b.Fatal(err)
	}

	b.ReportMetric(float64(duration.Nanoseconds()), "ns/op")
}

func BenchmarkIPv6Pass(b *testing.B) {
	benchSrcPortLimit := targetlimit.Limit{
		PacketsPerSecond: float64(100),
		BurstSec:         float64(5),
	}

	benchSrcNetLimit := targetlimit.Limit{
		PacketsPerSecond: float64(100),
		BurstSec:         float64(5),
	}

	benchSrcIPLimit := targetlimit.Limit{
		PacketsPerSecond: float64(100),
		BurstSec:         float64(5),
	}

	benchDstLimit := targetlimit.Limit{
		PacketsPerSecond: float64(100),
		BurstSec:         float64(5),
	}
	tl, err := targetlimit.NewTargetLimit(benchSrcPortLimit, benchSrcNetLimit, benchSrcIPLimit, benchDstLimit)
	if err != nil {
		b.Fatalf("[-] Can't load targetlimit for benchmark: %v", err)
	}
	defer tl.Close()

	if err := tl.SetProgram("bpf_rate_limit_benchmark"); err != nil {
		b.Fatal(err)
	}

	// this is dns for A cloudflare.com to to ffff::1
	payload := []byte{
		0x33, 0x33, 0x00, 0x00, 0x00, 0x01, 0xd8, 0x3b, 0xbf, 0xb2, 0xe6, 0x43, 0x86, 0xdd, 0x60, 0x09,
		0x01, 0x02, 0x00, 0x3f, 0x11, 0x01, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x1d,
		0x3f, 0xc3, 0xc0, 0xf2, 0x05, 0x4d, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xa3, 0x03, 0x00, 0x35, 0x00, 0x3f, 0x59, 0xf2, 0x62, 0x62,
		0x01, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0a, 0x63, 0x6c, 0x6f, 0x75, 0x64,
		0x66, 0x6c, 0x61, 0x72, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00,
		0x29, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0a, 0x00, 0x08, 0x02, 0xb2, 0x4c,
		0x1e, 0x27, 0xce, 0x20, 0x3e,
	}

	b.ResetTimer()
	result, duration, err := tl.Prog().Benchmark(payload, b.N, func() {
		b.ResetTimer()
	})
	_ = result
	if err != nil {
		b.Fatal(err)
	}

	b.ReportMetric(float64(duration.Nanoseconds()), "ns/op")
}

func BenchmarkIPv6Reject(b *testing.B) {
	zeroLimit := targetlimit.Limit{
		PacketsPerSecond: float64(10),
		BurstSec:         float64(0.0000000000000000000000000001),
	}

	tl, err := targetlimit.NewTargetLimit(zeroLimit, zeroLimit, zeroLimit, zeroLimit)
	if err != nil {
		b.Fatalf("[-] Can't load targetlimit for benchmark: %v", err)
	}
	defer tl.Close()

	// this is dns for A cloudflare.com to to ffff::1
	payload := []byte{
		0x33, 0x33, 0x00, 0x00, 0x00, 0x01, 0xd8, 0x3b, 0xbf, 0xb2, 0xe6, 0x43, 0x86, 0xdd, 0x60, 0x09,
		0x01, 0x02, 0x00, 0x3f, 0x11, 0x01, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x1d,
		0x3f, 0xc3, 0xc0, 0xf2, 0x05, 0x4d, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xa3, 0x03, 0x00, 0x35, 0x00, 0x3f, 0x59, 0xf2, 0x62, 0x62,
		0x01, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0a, 0x63, 0x6c, 0x6f, 0x75, 0x64,
		0x66, 0x6c, 0x61, 0x72, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00,
		0x29, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0a, 0x00, 0x08, 0x02, 0xb2, 0x4c,
		0x1e, 0x27, 0xce, 0x20, 0x3e,
	}

	// first we'll make sure it works as expected, we actually drop packets straight away
	// (we actually need to do it twice because first packets are passed by default)

	//first
	_, _, err = tl.Prog().Test(payload)
	if err != nil {
		b.Fatal(err)
	}

	//second
	ret, _, err := tl.Prog().Test(payload)
	if err != nil {
		b.Fatal(err)
	}

	//it should be rejected, rejected is 0, so ensure it actually is
	if ret != 0 {
		b.Fatal(ret)
	}

	b.ResetTimer()
	result, duration, err := tl.Prog().Benchmark(payload, b.N, func() {
		b.ResetTimer()
	})
	_ = result
	if err != nil {
		b.Fatal(err)
	}

	b.ReportMetric(float64(duration.Nanoseconds()), "ns/op")
}
